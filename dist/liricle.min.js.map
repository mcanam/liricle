{"version":3,"file":"liricle.min.js","sources":["../src/parser.js","../src/syncher.js","../src/liricle.js"],"sourcesContent":["// will match: \"[tag:value]\"\nconst TAG_REGEX = /\\[(ar|ti|al|au|by|length|offset|re|ve):(.*)\\]/i;\n\n// will match: \"[00:00.00]\"\nconst LINE_TIME_REGEX = /\\[\\d{2}:\\d{2}(.\\d{2,})?\\]/g;\n\n// will match: \"<00:00.00>\"\nconst WORD_TIME_REGEX = /<\\d{2}:\\d{2}(.\\d{2,})?>/g;\n\n// will match: \"<00:00.00> blablabla\"\nconst ENHANCED_REGEX = /<\\d{2}:\\d{2}(.\\d{2,})?>\\s*[^\\s|<]*/g;\n\n/**\n * parse lrc to javascript object\n * @param {string} lrc - lrc text\n * @returns {Object} parsed lrc data\n */\nexport default function parser(lrc) {\n      if (lrc == '' || !lrc.trim()) {\n            console.warn(\"[Liricle] LRC is empty.\");\n      }\n\n      const output = {\n            tags : {},\n            lines: [],\n            enhanced: isEnhanced(lrc)\n      };\n\n      const lines = lrc.split(/\\r?\\n/);\n\n      // parsing started\n      lines.forEach(value => {\n            const tag  = parseTag(value);\n            const line = parseLine(value);\n\n            if (tag)  output.tags[tag.key] = tag.value;\n            if (line) output.lines.push(...line);\n      });\n\n      // if lrc has multiple timestamps \"[mm:ss.xx]\" in the same line.\n      // parser will split into individual lines. so, we have to reorder them.\n      output.lines = sortLines(output.lines);\n\n      return output;\n}\n\n/**\n * parse lrc tag\n * @param {string} line - lrc line value\n * @return {(Object|undefined)} extrated tag object or undefined\n */\nfunction parseTag(line) {\n      const [, key, value] = line.match(TAG_REGEX) || [];\n      if (!key || !value) return;\n\n      return { key, value: value.trim() };\n}\n\n/**\n * parse time, text and words from lrc\n * @param {string} line - lrc line value\n * @return {(Array|undefined)} array that contains lrc line object or undefined\n */\nfunction parseLine(line) {\n      const output = [];\n      const timestamps = line.match(LINE_TIME_REGEX);\n\n      if (!timestamps) return;\n\n      // lrc can have multiple timestamps \"[mm:ss.xx]\" on the same line.\n      timestamps.forEach(timestamp => {\n            output.push({\n                  time : extractTime(timestamp),\n                  text : extractText(line),\n                  words: extractWords(line)\n            });\n      });\n\n      return output;\n}\n\n/**\n * extract time from lrc line and convert to seconds\n * @param {string} timestamp - time string \"[mm:ss.xx]\"\n * @returns {number} extracted time number in seconds\n */\nfunction extractTime(timestamp) {\n      let time = timestamp.replace(/\\[|\\]|<|>/g, \"\");\n      time = convertTime(time);\n\n      return time;\n}\n\n/**\n * extract text from lrc line\n * @param {string} line - lrc line\n * @returns {string} extracted text\n */\nfunction extractText(line) {\n      let text = line.replace(LINE_TIME_REGEX, \"\");\n          text = text.replace(WORD_TIME_REGEX, \"\");\n          text = text.replace(/\\s{2,}/g, \" \");\n\n      return text.trim();\n}\n\n/**\n * extract words from lrc line\n * @param {string} line - lrc line\n * @returns {(Array|null)} extracted words or null\n */\nfunction extractWords(line) {\n      const output = [];\n      const words = line.match(ENHANCED_REGEX);\n\n      if (!words) return null;\n\n      words.forEach(word => {\n            // extract timestamp \"<00:00.00>\" with regex\n            // i think it's easier than split them\n            const timestamp = word.match(WORD_TIME_REGEX)[0];\n\n            output.push({\n                  time: extractTime(timestamp),\n                  text: extractText(word)\n            });\n      });\n\n      return output;\n}\n\n/**\n * convert \"03:24.73\" to 204.73 (total time in seconds)\n * @param {string} time - time string \"mm:ss.xx\"\n * @returns {number} total time in secondsi\n */\nfunction convertTime(time) {\n      let [min, sec] = time.split(\":\");\n\n      min = parseFloat(min) * 60;\n      sec = parseFloat(sec);\n\n      return min + sec;\n}\n\n/**\n * sort lines by time (shortest to longest)\n * @param {Array} lines - array of lrc lines objects\n * @returns {Array} sorted lines\n */\nfunction sortLines(lines) {\n      return lines.sort((a, b) => a.time - b.time);\n}\n\n/**\n * check the lrc format is enhanced or not\n * @param {string} text - lrc text\n * @returns {boolean} is enhanced?\n */\nfunction isEnhanced(text) {\n      return ENHANCED_REGEX.test(text);\n}\n","/**\n * find closest word and line from given time\n * @param {Object} data - output data from parser\n * @param {number} time - current time from audio player or something else\n */\nexport default function syncher(data, time) {\n      let line = null;\n      let word = null;\n\n      const lines = data.lines;\n      line = findLine(lines, time);\n\n      if (line != null && data.enhanced) {\n            const words = line.words;\n            word = findWord(words, time);\n\n            // delete 'words' property from line\n            // because we don't need it anymore.\n            delete line.words;\n      }\n\n      return { line, word };\n}\n\n/**\n * find closest lyric line\n * @param {Array} lines - array of lrc lines object\n * @param {number} time - time argument\n * @returns {(Object|null)} closest lyric line or null\n */\nfunction findLine(lines, time) {\n      const index = getClosestIndex(lines, time);\n      return index != null ? { index, ...lines[index] } : null;\n}\n\n/**\n * find closest lyric word\n * @param {Array} words - array of lrc line words object\n * @param {number} time - time argument\n * @returns {(Object|null)} closest lyric word or null\n */\nfunction findWord(words, time) {\n      // if words are null, just return it.\n      if (words == null) return words;\n\n      const index = getClosestIndex(words, time);\n      return index != null ? { index, ...words[index] } : null;\n}\n\n/**\n *\n * @param {Array} items - array that contains lrc words or lines\n * @param {number} time - time argument\n * @returns {(number|null)} closest index of lyric or null\n */\nfunction getClosestIndex(items, time) {\n      // to find the closest index we just need to subtract each line or word time with the given time\n      // then put the value into an array and find the smallest positive value with Math.min()\n      // after that we can find the index from smallest value in array with indexOf() method.\n\n      const scores = [];\n\n      items.forEach(item => {\n            const score = time - item.time;\n            if (score >= 0) scores.push(score);\n      });\n\n      if (scores.length == 0) return null;\n\n      const smallest = Math.min(...scores);\n      const index = scores.indexOf(smallest);\n\n      return index;\n}\n","import parser from \"./parser.js\";\nimport syncher from \"./syncher.js\";\n\nexport default class Liricle {\n      #activeLine = null;\n      #activeWord = null;\n      #isLoaded = false;\n      #offset = 0;\n      #data = {};\n      #onLoad = () => {};\n      #onSync = () => {};\n\n      get data() {\n            return this.#data;\n      }\n\n      get offset() {\n            return this.#offset;\n      }\n\n      /**\n       * @param {number} value - lyric offset in milliseconds\n       */\n      set offset(value) {\n            value = parseFloat(value) / 1000; // convert value to seconds\n            this.#offset = value || 0; // if value is NaN, set 0\n      }\n\n      /**\n       * method to load lyrics\n       * @param {Object} options - object that contains 'url' or 'text' properties\n       * @param {string} options.text - lrc text\n       * @param {string} options.url - lrc file url\n       */\n      load(options = {}) {\n            this.#isLoaded = false;\n\n            if (options.text) { \n                  this.#data = parser(options.text);\n                  this.#isLoaded = true;\n                  this.#onLoad(this.#data);\n            }\n            \n            if (options.url) {\n                  fetch(options.url)\n                        .then(res => res.text())\n                        .then(text => {\n                              this.#data = parser(text);\n                              this.#isLoaded = true;\n                              this.#onLoad(this.#data);\n                        })\n                        .catch(error => {\n                              this.#isLoaded = false;\n                              throw Error(\"[Liricle] Failed to load LRC. \" + error.message);\n                        });\n            }\n      }\n\n      /**\n       * method to sync lyrics\n       * @param {number} time - current player time or something else in seconds\n       * @param {boolean} [continuous] - always emit sync event (optional)\n       */\n      sync(time, continuous = false) {\n            if (!this.#isLoaded) {\n                  // if lrc is not loaded, stop execution.\n                  return console.warn(\"[Liricle] LRC not loaded yet.\");\n            }\n\n            const { enhanced } = this.#data;\n            const { line, word } = syncher(this.#data, time + this.offset);\n\n            if (line == null && word == null) return;\n\n            if (continuous) {\n                  return this.#onSync(line, word);\n            }\n\n            const isSameLine = line.index == this.#activeLine;\n            const isSameWord = word != null && word.index == this.#activeWord;\n\n            if (enhanced && word != null) {\n                  if (isSameLine && isSameWord) return;\n            } else { \n                  if (isSameLine) return;\n            }\n\n            this.#onSync(line, word);\n\n            this.#activeLine = line.index;\n            this.#activeWord = word != null ? word.index : null;\n      }\n\n      /**\n       * listen to liricle event\n       * @param {string} event - event name\n       * @param {function} callback - event callback\n       */\n      on(event, callback) {\n            switch (event) {\n                  case \"load\":\n                        this.#onLoad = callback;\n                        break;\n                  case \"sync\":\n                        this.#onSync = callback;\n                        break;\n            }\n      }\n}\n"],"names":["TAG_REGEX","LINE_TIME_REGEX","WORD_TIME_REGEX","ENHANCED_REGEX","parser","lrc","trim","console","warn","output","tags","lines","enhanced","text","test","split","forEach","value","tag","line","key","match","parseTag","timestamps","timestamp","push","time","extractTime","extractText","words","extractWords","parseLine","sort","a","b","sortLines","replace","min","sec","parseFloat","convertTime","word","syncher","data","index","getClosestIndex","findLine","findWord","items","scores","item","score","length","smallest","Math","indexOf","activeLine","activeWord","isLoaded","offset","onLoad","onSync","this","load","options","url","fetch","then","res","catch","error","Error","message","sync","continuous","isSameLine","isSameWord","on","event","callback"],"mappings":";;;;;;wOACA,MAAMA,EAAY,iDAGZC,EAAkB,6BAGlBC,EAAkB,2BAGlBC,EAAiB,sCAOR,SAASC,EAAOC,GACd,IAAPA,GAAcA,EAAIC,QAChBC,QAAQC,KAAK,2BAGnB,MAAMC,EAAS,CACTC,KAAO,GACPC,MAAO,GACPC,UAsIQC,EAtIaR,EAuIpBF,EAAeW,KAAKD,KADjC,IAAoBA,EApHd,OAfcR,EAAIU,MAAM,SAGlBC,SAAQC,IACR,MAAMC,EAmBlB,SAAkBC,GACZ,MAAM,CAAGC,EAAKH,GAASE,EAAKE,MAAMrB,IAAc,GAChD,IAAKoB,IAAQH,EAAO,OAEpB,MAAO,CAAEG,IAAAA,EAAKH,MAAOA,EAAMX,QAvBRgB,CAASL,GAChBE,EA8BlB,SAAmBA,GACb,MAAMV,EAAS,GACTc,EAAaJ,EAAKE,MAAMpB,GAE9B,IAAKsB,EAAY,OAWjB,OARAA,EAAWP,SAAQQ,IACbf,EAAOgB,KAAK,CACNC,KAAOC,EAAYH,GACnBX,KAAOe,EAAYT,GACnBU,MAAOC,EAAaX,QAIzBV,EA7CYsB,CAAUd,GAEnBC,IAAMT,EAAOC,KAAKQ,EAAIE,KAAOF,EAAID,OACjCE,GAAMV,EAAOE,MAAMc,QAAQN,MAKrCV,EAAOE,MA6Gb,SAAmBA,GACb,OAAOA,EAAMqB,MAAK,CAACC,EAAGC,IAAMD,EAAEP,KAAOQ,EAAER,OA9GxBS,CAAU1B,EAAOE,OAEzBF,EA2Cb,SAASkB,EAAYH,GACf,IAAIE,EAAOF,EAAUY,QAAQ,aAAc,IAG3C,OAFAV,EAgDN,SAAqBA,GACf,IAAKW,EAAKC,GAAOZ,EAAKX,MAAM,KAK5B,OAHAsB,EAAwB,GAAlBE,WAAWF,GACjBC,EAAMC,WAAWD,GAEVD,EAAMC,EAtDNE,CAAYd,GAEZA,EAQb,SAASE,EAAYT,GACf,IAAIN,EAAOM,EAAKiB,QAAQnC,EAAiB,IAIzC,OAHIY,EAAOA,EAAKuB,QAAQlC,EAAiB,IACrCW,EAAOA,EAAKuB,QAAQ,UAAW,KAE5BvB,EAAKP,OAQlB,SAASwB,EAAaX,GAChB,MAAMV,EAAS,GACToB,EAAQV,EAAKE,MAAMlB,GAEzB,OAAK0B,GAELA,EAAMb,SAAQyB,IAGR,MAAMjB,EAAYiB,EAAKpB,MAAMnB,GAAiB,GAE9CO,EAAOgB,KAAK,CACNC,KAAMC,EAAYH,GAClBX,KAAMe,EAAYa,QAIvBhC,GAbY,KC9GV,SAASiC,EAAQC,EAAMjB,GAChC,IAAIP,EAAO,KACPsB,EAAO,KAKX,GAFAtB,EAoBN,SAAkBR,EAAOe,GACnB,MAAMkB,EAAQC,EAAgBlC,EAAOe,GACrC,OAAgB,MAATkB,EAAgB,CAAEA,MAAAA,KAAUjC,EAAMiC,IAAW,KAtB7CE,CADOH,EAAKhC,MACIe,GAEX,MAARP,GAAgBwB,EAAK/B,SAAU,CAE7B6B,EA2BZ,SAAkBZ,EAAOH,GAEnB,GAAa,MAATG,EAAe,OAAOA,EAE1B,MAAMe,EAAQC,EAAgBhB,EAAOH,GACrC,OAAgB,MAATkB,EAAgB,CAAEA,MAAAA,KAAUf,EAAMe,IAAW,KAhCvCG,CADO5B,EAAKU,MACIH,UAIhBP,EAAKU,MAGlB,MAAO,CAAEV,KAAAA,EAAMsB,KAAAA,GAkCrB,SAASI,EAAgBG,EAAOtB,GAK1B,MAAMuB,EAAS,GAOf,GALAD,EAAMhC,SAAQkC,IACR,MAAMC,EAAQzB,EAAOwB,EAAKxB,KACtByB,GAAS,GAAGF,EAAOxB,KAAK0B,MAGb,GAAjBF,EAAOG,OAAa,OAAO,KAE/B,MAAMC,EAAWC,KAAKjB,OAAOY,GAG7B,OAFcA,EAAOM,QAAQF,UCnEpB,MACTG,GAAc,KACdC,GAAc,KACdC,IAAY,EACZC,GAAU,EACVhB,GAAQ,GACRiB,GAAU,OACVC,GAAU,OAENlB,WACE,OAAOmB,MAAKnB,EAGdgB,aACE,OAAOG,MAAKH,EAMdA,WAAO1C,GACLA,EAAQsB,WAAWtB,GAAS,IAC5B6C,MAAKH,EAAU1C,GAAS,EAS9B8C,KAAKC,EAAU,IACTF,MAAKJ,GAAY,EAEbM,EAAQnD,OACNiD,MAAKnB,EAAQvC,EAAO4D,EAAQnD,MAC5BiD,MAAKJ,GAAY,EACjBI,MAAKF,EAAQE,MAAKnB,IAGpBqB,EAAQC,KACNC,MAAMF,EAAQC,KACPE,MAAKC,GAAOA,EAAIvD,SAChBsD,MAAKtD,IACAiD,MAAKnB,EAAQvC,EAAOS,GACpBiD,MAAKJ,GAAY,EACjBI,MAAKF,EAAQE,MAAKnB,MAEvB0B,OAAMC,IAED,MADAR,MAAKJ,GAAY,EACXa,MAAM,iCAAmCD,EAAME,YAU7EC,KAAK/C,EAAMgD,GAAa,GAClB,IAAKZ,MAAKJ,EAEJ,OAAOnD,QAAQC,KAAK,iCAG1B,MAAMI,SAAEA,GAAakD,MAAKnB,GACpBxB,KAAEA,EAAIsB,KAAEA,GAASC,EAAQoB,MAAKnB,EAAOjB,EAAOoC,KAAKH,QAEvD,GAAY,MAARxC,GAAwB,MAARsB,EAAc,OAElC,GAAIiC,EACE,OAAOZ,MAAKD,EAAQ1C,EAAMsB,GAGhC,MAAMkC,EAAaxD,EAAKyB,OAASkB,MAAKN,EAChCoB,EAAqB,MAARnC,GAAgBA,EAAKG,OAASkB,MAAKL,EAEtD,GAAI7C,GAAoB,MAAR6B,GACV,GAAIkC,GAAcC,EAAY,YAE9B,GAAID,EAAY,OAGtBb,MAAKD,EAAQ1C,EAAMsB,GAEnBqB,MAAKN,EAAcrC,EAAKyB,MACxBkB,MAAKL,EAAsB,MAARhB,EAAeA,EAAKG,MAAQ,KAQrDiC,GAAGC,EAAOC,GACJ,OAAQD,GACF,IAAK,OACChB,MAAKF,EAAUmB,EACf,MACN,IAAK,OACCjB,MAAKD,EAAUkB"}