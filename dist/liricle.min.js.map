{"version":3,"file":"liricle.min.js","sources":["../src/parser.js","../src/syncher.js","../src/liricle.js"],"sourcesContent":["// will match: \"[tag:value]\"\nconst TAG_REGEX = /\\[(ar|ti|al|au|by|length|offset|re|ve):(.*)\\]/i;\n\n// will match: \"[00:00.00]\"\nconst LINE_TIME_REGEX = /\\[\\d{2}:\\d{2}(.\\d{2,})?\\]/g;\n\n// will match: \"<00:00.00>\"\nconst WORD_TIME_REGEX = /<\\d{2}:\\d{2}(.\\d{2,})?>/g;\n\n// will match: \"<00:00.00> blablabla\"\nconst ENHANCED_REGEX = /<\\d{2}:\\d{2}(.\\d{2,})?>\\s*[^\\s|<]*/g;\n\n/**\n * parse lrc to javascript object\n * @param {string} lrc - lrc text\n * @returns {Object} parsed lrc data\n */\nexport default function parser(lrc) {\n      const output = {\n            tags : {},\n            lines: [],\n            enhanced: isEnhanced(lrc)\n      };\n\n      if (typeof lrc != 'string' || !lrc.trim()) {\n            console.warn(\"[Liricle] LRC is empty.\");\n            return output;\n      }\n\n      const lines = lrc.split(/\\r?\\n/);\n\n      // parsing started\n      lines.forEach(value => {\n            const tag  = parseTag(value);\n            const line = parseLine(value);\n\n            if (tag)  output.tags[tag.key] = tag.value;\n            if (line) output.lines.push(...line);\n      });\n\n      // if lrc has multiple timestamps \"[mm:ss.xx]\" in the same line.\n      // parser will split into individual lines. so, we have to reorder them.\n      output.lines = sortLines(output.lines);\n\n      return output;\n}\n\n/**\n * parse lrc tag\n * @param {string} line - lrc line value\n * @return {(Object|undefined)} extrated tag object or undefined\n */\nfunction parseTag(line) {\n      const [, key, value] = line.match(TAG_REGEX) || [];\n      if (!key || !value) return;\n\n      return { key, value: value.trim() };\n}\n\n/**\n * parse time, text and words from lrc\n * @param {string} line - lrc line value\n * @return {(Array|undefined)} array that contains lrc line object or undefined\n */\nfunction parseLine(line) {\n      const output = [];\n      const timestamps = line.match(LINE_TIME_REGEX);\n\n      if (!timestamps) return;\n\n      // lrc can have multiple timestamps \"[mm:ss.xx]\" on the same line.\n      timestamps.forEach(timestamp => {\n            output.push({\n                  time : extractTime(timestamp),\n                  text : extractText(line),\n                  words: extractWords(line)\n            });\n      });\n\n      return output;\n}\n\n/**\n * extract time from lrc line and convert to seconds\n * @param {string} timestamp - time string \"[mm:ss.xx]\"\n * @returns {number} extracted time number in seconds\n */\nfunction extractTime(timestamp) {\n      let time = timestamp.replace(/\\[|\\]|<|>/g, \"\");\n      time = convertTime(time);\n\n      return time;\n}\n\n/**\n * extract text from lrc line\n * @param {string} line - lrc line\n * @returns {string} extracted text\n */\nfunction extractText(line) {\n      let text = line.replace(LINE_TIME_REGEX, \"\");\n          text = text.replace(WORD_TIME_REGEX, \"\");\n          text = text.replace(/\\s{2,}/g, \" \");\n\n      return text.trim();\n}\n\n/**\n * extract words from lrc line\n * @param {string} line - lrc line\n * @returns {(Array|null)} extracted words or null\n */\nfunction extractWords(line) {\n      const output = [];\n      const words = line.match(ENHANCED_REGEX);\n\n      if (!words) return null;\n\n      words.forEach(word => {\n            // extract timestamp \"<00:00.00>\" with regex\n            // i think it's easier than split them\n            const timestamp = word.match(WORD_TIME_REGEX)[0];\n\n            output.push({\n                  time: extractTime(timestamp),\n                  text: extractText(word)\n            });\n      });\n\n      return output;\n}\n\n/**\n * convert \"03:24.73\" to 204.73 (total time in seconds)\n * @param {string} time - time string \"mm:ss.xx\"\n * @returns {number} total time in secondsi\n */\nfunction convertTime(time) {\n      let [min, sec] = time.split(\":\");\n\n      min = parseFloat(min) * 60;\n      sec = parseFloat(sec);\n\n      return min + sec;\n}\n\n/**\n * sort lines by time (shortest to longest)\n * @param {Array} lines - array of lrc lines objects\n * @returns {Array} sorted lines\n */\nfunction sortLines(lines) {\n      return lines.sort((a, b) => a.time - b.time);\n}\n\n/**\n * check the lrc format is enhanced or not\n * @param {string} text - lrc text\n * @returns {boolean} is enhanced?\n */\nfunction isEnhanced(text) {\n      return ENHANCED_REGEX.test(text);\n}\n","/**\n * find closest word and line from given time\n * @param {Object} data - output data from parser\n * @param {number} time - current time from audio player or something else\n */\nexport default function syncher(data, time) {\n      let line = null;\n      let word = null;\n\n      const lines = data.lines;\n      line = findLine(lines, time);\n\n      if (line != null) {\n            if (data.enhanced) {\n                  const words = line.words;\n                  word = findWord(words, time);\n            }\n\n            // delete 'words' property from line\n            // because we don't need it anymore.\n            delete line.words;\n      }\n\n      return { line, word };\n}\n\n/**\n * find closest lyric line\n * @param {Array} lines - array of lrc lines object\n * @param {number} time - time argument\n * @returns {(Object|null)} closest lyric line or null\n */\nfunction findLine(lines, time) {\n      const index = getClosestIndex(lines, time);\n      return index != null ? { index, ...lines[index] } : null;\n}\n\n/**\n * find closest lyric word\n * @param {Array} words - array of lrc line words object\n * @param {number} time - time argument\n * @returns {(Object|null)} closest lyric word or null\n */\nfunction findWord(words, time) {\n      // if words are null, just return it.\n      if (words == null) return words;\n\n      const index = getClosestIndex(words, time);\n      return index != null ? { index, ...words[index] } : null;\n}\n\n/**\n *\n * @param {Array} items - array that contains lrc words or lines\n * @param {number} time - time argument\n * @returns {(number|null)} closest index of lyric or null\n */\nfunction getClosestIndex(items, time) {\n      // to find the closest index we just need to subtract each line or word time with the given time\n      // then put the value into an array and find the smallest positive value with Math.min()\n      // after that we can find the index from smallest value in array with indexOf() method.\n\n      const scores = [];\n\n      items.forEach(item => {\n            const score = time - item.time;\n            if (score >= 0) scores.push(score);\n      });\n\n      if (scores.length == 0) return null;\n\n      const smallest = Math.min(...scores);\n      const index = scores.indexOf(smallest);\n\n      return index;\n}\n","import parser from \"./parser.js\";\nimport syncher from \"./syncher.js\";\n\nexport default class Liricle {\n      #activeLine = null;\n      #activeWord = null;\n      #isLoaded = false;\n      #offset = 0;\n      #data = {};\n      #onLoad = () => {};\n      #onSync = () => {};\n\n      get data() {\n            return this.#data;\n      }\n\n      get offset() {\n            return this.#offset;\n      }\n\n      /**\n       * @param {number} value - lyric offset in milliseconds\n       */\n      set offset(value) {\n            value = parseFloat(value) / 1000; // convert value to seconds\n            this.#offset = value || 0; // if value is NaN, set 0\n      }\n\n      /**\n       * method to load lyrics\n       * @param {Object} options - object that contains 'url' or 'text' properties\n       * @param {string} options.text - lrc text\n       * @param {string} options.url - lrc file url\n       */\n      load(options = {}) {\n            this.#isLoaded = false;\n\n            if (options.text) { \n                  this.#data = parser(options.text);\n                  this.#isLoaded = true;\n                  this.#onLoad(this.#data);\n            }\n            \n            if (options.url) {\n                  fetch(options.url)\n                        .then(res => res.text())\n                        .then(text => {\n                              this.#data = parser(text);\n                              this.#isLoaded = true;\n                              this.#onLoad(this.#data);\n                        })\n                        .catch(error => {\n                              this.#isLoaded = false;\n                              throw Error(\"[Liricle] Failed to load LRC. \" + error.message);\n                        });\n            }\n      }\n\n      /**\n       * method to sync lyrics\n       * @param {number} time - current player time or something else in seconds\n       * @param {boolean} [continuous] - always emit sync event (optional)\n       */\n      sync(time, continuous = false) {\n            if (!this.#isLoaded) {\n                  // if lrc is not loaded, stop execution.\n                  return console.warn(\"[Liricle] LRC not loaded yet.\");\n            }\n\n            const { enhanced } = this.#data;\n            const { line, word } = syncher(this.#data, time + this.offset);\n\n            if (line == null && word == null) return;\n\n            if (continuous) {\n                  return this.#onSync(line, word);\n            }\n\n            const isSameLine = line.index == this.#activeLine;\n            const isSameWord = word != null && word.index == this.#activeWord;\n\n            if (enhanced && word != null) {\n                  if (isSameLine && isSameWord) return;\n            } else { \n                  if (isSameLine) return;\n            }\n\n            this.#onSync(line, word);\n\n            this.#activeLine = line.index;\n            this.#activeWord = word != null ? word.index : null;\n      }\n\n      /**\n       * listen to liricle event\n       * @param {string} event - event name\n       * @param {function} callback - event callback\n       */\n      on(event, callback) {\n            switch (event) {\n                  case \"load\":\n                        this.#onLoad = callback;\n                        break;\n                  case \"sync\":\n                        this.#onSync = callback;\n                        break;\n            }\n      }\n}\n"],"names":["TAG_REGEX","LINE_TIME_REGEX","WORD_TIME_REGEX","ENHANCED_REGEX","parser","lrc","output","tags","lines","enhanced","text","test","trim","console","warn","split","forEach","value","tag","line","key","match","parseTag","timestamps","timestamp","push","time","extractTime","extractText","words","extractWords","parseLine","sort","a","b","sortLines","replace","min","sec","parseFloat","convertTime","word","syncher","data","index","getClosestIndex","findLine","findWord","items","scores","item","score","length","smallest","Math","indexOf","activeLine","activeWord","isLoaded","offset","onLoad","onSync","this","load","options","url","fetch","then","res","catch","error","Error","message","sync","continuous","isSameLine","isSameWord","on","event","callback"],"mappings":"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"}